"""
Matchup Exploiter Service
Analyzes favorable matchups, schedule lookahead, and defensive weaknesses
"""

from typing import List, Dict, Optional
from app.services.api_client import FantasyAPIClient
from app.services.analyzer import PlayerAnalyzer
import logging

logger = logging.getLogger(__name__)


class MatchupExploiter:
    """
    Service for finding favorable matchups and exploiting defensive weaknesses
    """

    def __init__(self):
        self.api_client = FantasyAPIClient()
        self.analyzer = PlayerAnalyzer()

    def find_favorable_matchups(
        self,
        position: Optional[str] = None,
        week: Optional[int] = None,
        season: int = 2024,
        min_ownership: float = 0.0,
        max_ownership: float = 50.0
    ) -> Dict:
        """
        Find players with favorable matchups (facing weak defenses)

        Args:
            position: Filter by position (QB, RB, WR, TE)
            week: Week number for matchup analysis
            season: NFL season year
            min_ownership: Minimum ownership % (for waiver wire)
            max_ownership: Maximum ownership % (for waiver wire)

        Returns:
            Dict with favorable matchup players and their scores
        """
        try:
            logger.info(f"Finding favorable matchups for position={position}, week={week}")

            # Get defensive rankings
            defense_rankings = self.api_client.get_defense_rankings_v2(
                category='overall',
                season=season
            )

            if not defense_rankings or 'data' not in defense_rankings:
                logger.error("Failed to get defense rankings")
                return {'players': [], 'error': 'Defense rankings unavailable'}

            # Identify weak defenses (bottom 10)
            weak_defenses = self._identify_weak_defenses(
                defense_rankings['data'],
                position=position
            )

            # Get upcoming games for the week
            games = self.api_client.get_games_v2(
                season=season,
                week=week,
                limit=20
            )

            if not games or 'data' not in games:
                logger.error(f"Failed to get games for week {week}")
                return {'players': [], 'error': 'Games data unavailable'}

            # Find players facing weak defenses
            favorable_matchups = self._match_players_to_weak_defenses(
                games['data'],
                weak_defenses,
                position=position,
                min_ownership=min_ownership,
                max_ownership=max_ownership
            )

            # Sort by matchup score (best matchups first)
            favorable_matchups.sort(key=lambda x: x.get('matchup_score', 0), reverse=True)

            return {
                'players': favorable_matchups[:20],  # Top 20
                'weak_defenses': weak_defenses,
                'week': week,
                'season': season
            }

        except Exception as e:
            logger.error(f"Error finding favorable matchups: {str(e)}")
            return {'players': [], 'error': str(e)}

    def get_schedule_lookahead(
        self,
        player_id: str,
        weeks_ahead: int = 4,
        season: int = 2024
    ) -> Dict:
        """
        Get schedule lookahead for a player (next 3-4 weeks)

        Args:
            player_id: Player ID
            weeks_ahead: Number of weeks to look ahead
            season: NFL season year

        Returns:
            Dict with schedule analysis and difficulty ratings
        """
        try:
            logger.info(f"Getting schedule lookahead for player {player_id}")

            # Get player details
            player = self.api_client.get_player_by_id_v2(player_id)
            if not player or 'data' not in player:
                return {'error': 'Player not found'}

            player_data = player['data']
            player_team = player_data.get('team_id') or player_data.get('team')

            # Get team schedule
            schedule = self.api_client.get_team_schedule_detailed_v2(
                team_id=player_team,
                season=season
            )

            if not schedule or 'data' not in schedule:
                return {'error': 'Schedule not available'}

            # Get defense rankings
            defense_rankings = self.api_client.get_defense_rankings_v2(
                category='overall',
                season=season
            )

            # Analyze upcoming matchups
            upcoming_matchups = self._analyze_upcoming_matchups(
                schedule['data'],
                defense_rankings.get('data', []) if defense_rankings else [],
                player_data,
                weeks_ahead=weeks_ahead
            )

            # Calculate schedule difficulty
            difficulty_score = self._calculate_schedule_difficulty(upcoming_matchups)

            return {
                'player': {
                    'id': player_id,
                    'name': player_data.get('name'),
                    'position': player_data.get('position'),
                    'team': player_team
                },
                'upcoming_matchups': upcoming_matchups,
                'difficulty_score': difficulty_score,
                'difficulty_rating': self._get_difficulty_rating(difficulty_score),
                'weeks_analyzed': weeks_ahead
            }

        except Exception as e:
            logger.error(f"Error getting schedule lookahead: {str(e)}")
            return {'error': str(e)}

    def get_defense_heatmap(
        self,
        position: Optional[str] = None,
        season: int = 2024
    ) -> Dict:
        """
        Get defensive weakness heatmap for all NFL teams

        Args:
            position: Filter by position (QB, RB, WR, TE)
            season: NFL season year

        Returns:
            Dict with defense rankings and heatmap data
        """
        try:
            logger.info(f"Getting defense heatmap for position={position}")

            # Get all teams
            teams = self.api_client.get_teams_list_v2()
            if not teams or 'data' not in teams:
                return {'error': 'Teams data unavailable'}

            # Get defense rankings
            defense_rankings = self.api_client.get_defense_rankings_v2(
                category='overall',
                season=season
            )

            if not defense_rankings or 'data' not in defense_rankings:
                return {'error': 'Defense rankings unavailable'}

            # Build heatmap data
            heatmap_data = self._build_heatmap_data(
                teams['data'],
                defense_rankings['data'],
                position=position
            )

            return {
                'heatmap': heatmap_data,
                'position': position,
                'season': season,
                'legend': {
                    'excellent': {'range': '0-20%', 'color': 'green', 'description': 'Weak defense - exploit'},
                    'good': {'range': '20-40%', 'color': 'lightgreen', 'description': 'Below average'},
                    'average': {'range': '40-60%', 'color': 'yellow', 'description': 'Average defense'},
                    'tough': {'range': '60-80%', 'color': 'orange', 'description': 'Above average'},
                    'elite': {'range': '80-100%', 'color': 'red', 'description': 'Elite defense - avoid'}
                }
            }

        except Exception as e:
            logger.error(f"Error getting defense heatmap: {str(e)}")
            return {'error': str(e)}

    def _identify_weak_defenses(
        self,
        defense_data: List[Dict],
        position: Optional[str] = None
    ) -> List[Dict]:
        """Identify weak defenses (bottom 10 ranked)"""
        # Sort by rank (higher rank number = worse defense)
        sorted_defenses = sorted(
            defense_data,
            key=lambda x: x.get('rank', 999),
            reverse=True
        )

        # Return bottom 10
        weak_defenses = sorted_defenses[:10]

        return [
            {
                'team_id': d.get('team_id'),
                'team_name': d.get('team_name'),
                'rank': d.get('rank'),
                'points_allowed': d.get('points_allowed'),
                'yards_allowed': d.get('yards_allowed')
            }
            for d in weak_defenses
        ]

    def _match_players_to_weak_defenses(
        self,
        games: List[Dict],
        weak_defenses: List[Dict],
        position: Optional[str] = None,
        min_ownership: float = 0.0,
        max_ownership: float = 50.0
    ) -> List[Dict]:
        """Match players to games against weak defenses"""
        favorable_matchups = []

        weak_defense_ids = {d['team_id'] for d in weak_defenses}

        for game in games:
            home_team = game.get('home_team_id')
            away_team = game.get('away_team_id')

            # Check if either team is facing a weak defense
            if home_team in weak_defense_ids:
                # Away team players have favorable matchup
                favorable_matchups.append({
                    'team_facing_weak_defense': away_team,
                    'weak_defense_team': home_team,
                    'game_id': game.get('id'),
                    'matchup_score': 85  # High score for weak defense
                })

            if away_team in weak_defense_ids:
                # Home team players have favorable matchup
                favorable_matchups.append({
                    'team_facing_weak_defense': home_team,
                    'weak_defense_team': away_team,
                    'game_id': game.get('id'),
                    'matchup_score': 85
                })

        return favorable_matchups

    def _analyze_upcoming_matchups(
        self,
        schedule: List[Dict],
        defense_rankings: List[Dict],
        player_data: Dict,
        weeks_ahead: int = 4
    ) -> List[Dict]:
        """Analyze upcoming matchups for difficulty"""
        upcoming = []

        for game in schedule[:weeks_ahead]:
            opponent = game.get('opponent_team_id')

            # Find opponent's defensive ranking
            opp_defense = next(
                (d for d in defense_rankings if d.get('team_id') == opponent),
                None
            )

            difficulty = 'Unknown'
            if opp_defense:
                rank = opp_defense.get('rank', 16)
                if rank <= 8:
                    difficulty = 'Easy'
                elif rank <= 16:
                    difficulty = 'Medium'
                else:
                    difficulty = 'Hard'

            upcoming.append({
                'week': game.get('week'),
                'opponent': opponent,
                'opponent_name': game.get('opponent_name', 'Unknown'),
                'defense_rank': opp_defense.get('rank') if opp_defense else None,
                'difficulty': difficulty,
                'matchup_score': 100 - (opp_defense.get('rank', 16) * 3) if opp_defense else 50
            })

        return upcoming

    def _calculate_schedule_difficulty(self, matchups: List[Dict]) -> float:
        """Calculate overall schedule difficulty (0-100)"""
        if not matchups:
            return 50.0

        total_score = sum(m.get('matchup_score', 50) for m in matchups)
        avg_score = total_score / len(matchups)

        return round(avg_score, 1)

    def _get_difficulty_rating(self, score: float) -> str:
        """Convert difficulty score to rating"""
        if score >= 75:
            return 'Easy'
        elif score >= 50:
            return 'Medium'
        else:
            return 'Hard'

    def _build_heatmap_data(
        self,
        teams: List[Dict],
        defense_rankings: List[Dict],
        position: Optional[str] = None
    ) -> List[Dict]:
        """Build heatmap data structure"""
        heatmap = []

        for team in teams:
            team_id = team.get('id') or team.get('team_id')

            # Find defense ranking
            defense = next(
                (d for d in defense_rankings if d.get('team_id') == team_id),
                None
            )

            if defense:
                rank = defense.get('rank', 16)
                percentile = (rank / 32) * 100  # Convert to percentile

                heatmap.append({
                    'team_id': team_id,
                    'team_name': team.get('name'),
                    'team_abbr': team.get('abbreviation'),
                    'division': team.get('division'),
                    'conference': team.get('conference'),
                    'defense_rank': rank,
                    'percentile': round(percentile, 1),
                    'color_category': self._get_color_category(percentile)
                })

        return heatmap

    def _get_color_category(self, percentile: float) -> str:
        """Get color category for heatmap"""
        if percentile <= 20:
            return 'excellent'
        elif percentile <= 40:
            return 'good'
        elif percentile <= 60:
            return 'average'
        elif percentile <= 80:
            return 'tough'
        else:
            return 'elite'
